"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * whatsapp-bridge Node Api
 * The whatsapp-bridge API description
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatsApi = exports.ChatsApiFactory = exports.ChatsApiFp = exports.ChatsApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
/**
 * ChatsApi - axios parameter creator
 * @export
 */
const ChatsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {AssignToMeDto} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignToSeller: (body_1, ...args_1) => __awaiter(this, [body_1, ...args_1], void 0, function* (body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling assignToSeller.');
            }
            const localVarPath = `/api/chats/assign-to-seller`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {AssignmentTypeDto} body
         * @param {string} cellphone
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignmentType: (body_1, cellphone_1, id_1, ...args_1) => __awaiter(this, [body_1, cellphone_1, id_1, ...args_1], void 0, function* (body, cellphone, id, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling assignmentType.');
            }
            // verify required parameter 'cellphone' is not null or undefined
            if (cellphone === null || cellphone === undefined) {
                throw new base_1.RequiredError('cellphone', 'Required parameter cellphone was null or undefined when calling assignmentType.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling assignmentType.');
            }
            const localVarPath = `/api/chats/{cellphone}/assignment-type`
                .replace(`{${"cellphone"}}`, encodeURIComponent(String(cellphone)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChat: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getChat.');
            }
            const localVarPath = `/api/chats/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} branchId
         * @param {string} apikey
         * @param {string} [q]
         * @param {boolean} [unassigned]
         * @param {boolean} [unread]
         * @param {number} [rowsPerPage]
         * @param {number} [currentPage]
         * @param {number} [userId]
         * @param {boolean} [externallyInitiated]
         * @param {number} [id]
         * @param {string} [assignmentTypeCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChats: (branchId_1, apikey_1, q_1, unassigned_1, unread_1, rowsPerPage_1, currentPage_1, userId_1, externallyInitiated_1, id_1, assignmentTypeCode_1, ...args_1) => __awaiter(this, [branchId_1, apikey_1, q_1, unassigned_1, unread_1, rowsPerPage_1, currentPage_1, userId_1, externallyInitiated_1, id_1, assignmentTypeCode_1, ...args_1], void 0, function* (branchId, apikey, q, unassigned, unread, rowsPerPage, currentPage, userId, externallyInitiated, id, assignmentTypeCode, options = {}) {
            // verify required parameter 'branchId' is not null or undefined
            if (branchId === null || branchId === undefined) {
                throw new base_1.RequiredError('branchId', 'Required parameter branchId was null or undefined when calling getChats.');
            }
            // verify required parameter 'apikey' is not null or undefined
            if (apikey === null || apikey === undefined) {
                throw new base_1.RequiredError('apikey', 'Required parameter apikey was null or undefined when calling getChats.');
            }
            const localVarPath = `/api/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }
            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }
            if (rowsPerPage !== undefined) {
                localVarQueryParameter['rowsPerPage'] = rowsPerPage;
            }
            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (branchId !== undefined) {
                localVarQueryParameter['branchId'] = branchId;
            }
            if (externallyInitiated !== undefined) {
                localVarQueryParameter['externallyInitiated'] = externallyInitiated;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (assignmentTypeCode !== undefined) {
                localVarQueryParameter['assignmentTypeCode'] = assignmentTypeCode;
            }
            if (apikey !== undefined && apikey !== null) {
                localVarHeaderParameter['apikey'] = String(apikey);
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {MarkChatUnreadDto} body
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markChatUnread: (body_1, id_1, ...args_1) => __awaiter(this, [body_1, id_1, ...args_1], void 0, function* (body, id, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling markChatUnread.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling markChatUnread.');
            }
            const localVarPath = `/api/chats/{id}/mark-chat-unread`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ChatsApiAxiosParamCreator = ChatsApiAxiosParamCreator;
/**
 * ChatsApi - functional programming interface
 * @export
 */
const ChatsApiFp = function (configuration) {
    return {
        /**
         *
         * @param {AssignToMeDto} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignToSeller(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield (0, exports.ChatsApiAxiosParamCreator)(configuration).assignToSeller(body, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {AssignmentTypeDto} body
         * @param {string} cellphone
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignmentType(body, cellphone, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield (0, exports.ChatsApiAxiosParamCreator)(configuration).assignmentType(body, cellphone, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChat(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield (0, exports.ChatsApiAxiosParamCreator)(configuration).getChat(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} branchId
         * @param {string} apikey
         * @param {string} [q]
         * @param {boolean} [unassigned]
         * @param {boolean} [unread]
         * @param {number} [rowsPerPage]
         * @param {number} [currentPage]
         * @param {number} [userId]
         * @param {boolean} [externallyInitiated]
         * @param {number} [id]
         * @param {string} [assignmentTypeCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChats(branchId, apikey, q, unassigned, unread, rowsPerPage, currentPage, userId, externallyInitiated, id, assignmentTypeCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield (0, exports.ChatsApiAxiosParamCreator)(configuration).getChats(branchId, apikey, q, unassigned, unread, rowsPerPage, currentPage, userId, externallyInitiated, id, assignmentTypeCode, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {MarkChatUnreadDto} body
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markChatUnread(body, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield (0, exports.ChatsApiAxiosParamCreator)(configuration).markChatUnread(body, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.ChatsApiFp = ChatsApiFp;
/**
 * ChatsApi - factory interface
 * @export
 */
const ChatsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {AssignToMeDto} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignToSeller(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return (0, exports.ChatsApiFp)(configuration).assignToSeller(body, options).then((request) => request(axios, basePath));
            });
        },
        /**
         *
         * @param {AssignmentTypeDto} body
         * @param {string} cellphone
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignmentType(body, cellphone, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return (0, exports.ChatsApiFp)(configuration).assignmentType(body, cellphone, id, options).then((request) => request(axios, basePath));
            });
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChat(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return (0, exports.ChatsApiFp)(configuration).getChat(id, options).then((request) => request(axios, basePath));
            });
        },
        /**
         *
         * @param {number} branchId
         * @param {string} apikey
         * @param {string} [q]
         * @param {boolean} [unassigned]
         * @param {boolean} [unread]
         * @param {number} [rowsPerPage]
         * @param {number} [currentPage]
         * @param {number} [userId]
         * @param {boolean} [externallyInitiated]
         * @param {number} [id]
         * @param {string} [assignmentTypeCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChats(branchId, apikey, q, unassigned, unread, rowsPerPage, currentPage, userId, externallyInitiated, id, assignmentTypeCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return (0, exports.ChatsApiFp)(configuration).getChats(branchId, apikey, q, unassigned, unread, rowsPerPage, currentPage, userId, externallyInitiated, id, assignmentTypeCode, options).then((request) => request(axios, basePath));
            });
        },
        /**
         *
         * @param {MarkChatUnreadDto} body
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markChatUnread(body, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return (0, exports.ChatsApiFp)(configuration).markChatUnread(body, id, options).then((request) => request(axios, basePath));
            });
        },
    };
};
exports.ChatsApiFactory = ChatsApiFactory;
/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
class ChatsApi extends base_1.BaseAPI {
    /**
     *
     * @param {AssignToMeDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    assignToSeller(body, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, exports.ChatsApiFp)(this.configuration).assignToSeller(body, options).then((request) => request(this.axios, this.basePath));
        });
    }
    /**
     *
     * @param {AssignmentTypeDto} body
     * @param {string} cellphone
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    assignmentType(body, cellphone, id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, exports.ChatsApiFp)(this.configuration).assignmentType(body, cellphone, id, options).then((request) => request(this.axios, this.basePath));
        });
    }
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    getChat(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, exports.ChatsApiFp)(this.configuration).getChat(id, options).then((request) => request(this.axios, this.basePath));
        });
    }
    /**
     *
     * @param {number} branchId
     * @param {string} apikey
     * @param {string} [q]
     * @param {boolean} [unassigned]
     * @param {boolean} [unread]
     * @param {number} [rowsPerPage]
     * @param {number} [currentPage]
     * @param {number} [userId]
     * @param {boolean} [externallyInitiated]
     * @param {number} [id]
     * @param {string} [assignmentTypeCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    getChats(branchId, apikey, q, unassigned, unread, rowsPerPage, currentPage, userId, externallyInitiated, id, assignmentTypeCode, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, exports.ChatsApiFp)(this.configuration).getChats(branchId, apikey, q, unassigned, unread, rowsPerPage, currentPage, userId, externallyInitiated, id, assignmentTypeCode, options).then((request) => request(this.axios, this.basePath));
        });
    }
    /**
     *
     * @param {MarkChatUnreadDto} body
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    markChatUnread(body, id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, exports.ChatsApiFp)(this.configuration).markChatUnread(body, id, options).then((request) => request(this.axios, this.basePath));
        });
    }
}
exports.ChatsApi = ChatsApi;
